Web VPython 3.2




N = 4 # N by N by N array of atoms
# Surrounding the N**3 atoms is another layer of invisible fixed-position atoms
# that provide stability to the lattice.
k = 1
m = 1
spacing = 1
atom_radius = 0.18*spacing
L0 = spacing-1.8*atom_radius
V0 = pi*(0.5*atom_radius)**2*L0 # initial volume of spring
scene.center = 0.5*(N-1)*vector(1,1,1)
axes = [vector(1,0,0), vector(0,1,0), vector(0,0,1)]

scene.caption= """A model of a solid represented as atoms connected by interatomic bonds.

To rotate "camera", drag with right button or Ctrl-drag.
To zoom, drag with middle button or Alt/Option depressed, or use scroll wheel.
  On a two-button mouse, middle is left + right.
To pan left/right and up/down, Shift-drag.
Touch screen: pinch/extend to zoom, swipe or two-finger rotate."""


class crystal:
        
    def __init__(self,  N, atom_radius, spacing):
        self.atoms = []
        self.springs = []
        self.atoms2 = []
     
        for z in range(0,N,1):
            for y in range(0,N,1):
                for x in range(0,N,1):
                    atom = sphere()
                    atom.pos = vector(x,y,z)*spacing
                    atom.radius = atom_radius
                    atom.color = vector(0,0.58,0.69)
                    self.atoms.append( atom )
                    
        for z in range(0,N-1,1):
            for y in range(0,N-1,1):
                for x in range(0,N-1,1):
                    atom2 = sphere()
                    atom2.pos = vector(x+0.5,y+0.5,z+0.5)*spacing
                    atom2.radius = atom_radius
                    atom2.color = color.red
                    self.atoms2.append( atom2 )
        
        for z in range(0,N,1):
            for y in range(0,N,1):
                for x in range(0,N,1):
                    
                    i = x + y*N + z*N*N
                    atom = self.atoms[i]
                    
                    if x < N-1:
                        j = x+1 + y*N + z*N*N
                        self.make_spring(atom, self.atoms[j])

                    if y < N-1:
                        j = x + (y+1)*N + z*N*N
                        self.make_spring(atom, self.atoms[j])

                    if z < N-1:
                        j = x + y*N + (z+1)*N*N
                        self.make_spring(atom, self.atoms[j])
                    
        for z in range(0,N-1,1):
            for y in range(0,N-1,1):
                for x in range(0,N-1,1):
                    
                    i = x + y*(N-1) + z*(N-1)*(N-1)
                    atom2 = self.atoms2[i]
                    
                    corners = [(x, y, z), (x+1, y, z), (x, y+1, z), (x, y, z+1), (x+1, y+1, z), (x+1, y, z+1), (x, y+1, z+1), (x+1, y+1, z+1)]
                    
                    for (cx, cy, cz) in corners:
                        j = cx + cy*N + cz*N*N
                        self.make_spring(atom2, self.atoms[j])
                        
                        

             
                    

                   
                   




    # Create a grid of springs linking each atom to the adjacent atoms
    # in each dimension, or to invisible motionless atoms
    def make_spring(self, start, end):
        spring = cylinder()
        spring.pos = start.pos
        spring.axis = end.pos-start.pos
        spring.radius = 0.15*atom_radius
        spring.start = start
        spring.end = end
        spring.color = color.orange

c = crystal(N, atom_radius, spacing)
